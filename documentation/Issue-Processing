Issue management and planning is primarily done with:

- availability,
- project phase, and
- skill set.

In addition, we also deal with two secondary attributes:

- priority and
- project component.

Issue planners deal with the whole set of issues, making sure issue are fully
defined and correctly reference other issues. Developers, system admins,
technical writers and other issues consumers pick off the available issues
according to their skill set, phase, and priority.

== Issue DB and Management Tools ==

While the process may be used with various tools, we explicitly support Github
+ Codetree. Atlassian's JIRA product is also known to be compatible with the
process.

== Issue Specification ==

=== Availability ===

An issue is considered available if it has no unmet dependencies and is not
labeled as 'draft'. Any available issue is available to be worked and may be
selected. Generally workers should prefer issues matching their skill set in
the earliest incomplete project phase.

=== Project Phase ===

The project phase define iterative 'goals sets' for the project. "By phase
one, we will achieve features P and Q, by phase two, we will achieve X and Y."
Note that we use "phases" rather than dates as we envision planning as a
bottom up process in which we identify "first this, then that" independent of
external dates.

In many instances, the phases will be aligned with dates, but this should be
done after each phase is (more or less) defined. Otherwise, one runs the risk
of obsucuring "what can be done" with "what must be done".

==== Release Planning ====

In most cases, planning begins with a "X.Y Release". Release planning may
begin with brainstorming and sorting issues for a particular release. The
"next release" is often broken down into chunks which prioritize and / or
group issues into internal milestones. Future (post-next) releases may be
reasonably left as otherwise unsorted issue buckets.

Upcoming releases, and most especially the next release are, especially for
larger projects with many issues, broken into smaller phases. The phases may
target both iterative and parallel development depending on the feature
relationships and resources available.

==== MVP, Bonus, and Release ====

In particular, breaking the release goals into "MVP", "Bonus" and "Release"
milestones can help with setting priorities and resource planning. Note that
this roughly corresponds to an "Alpha, Beta, Gold" paradigm.

The process begins by talking about the release goals, which are captured in
the "X.Y Release" milestone issues, or may be immediately sorted into the "X.Y
MVP" and "X.Y Bonus" milestones. Either way, the goal is to enumerate a good
portion of the foreseeable or hoped-for goals.

Once a workable first draft of goals and obvious work is defined, the issues
are reviewed. Absolutely necessary user features are placed in the MVP
milestone. All other user features are sorted to the Bonus
milestone. Optimizations, polish, documentation as well as test and "external"
issues (e.g.: license acquisitions) are generally left to the Release
milestone, though there is no hard and fast rule.

Note that he difference between MVP-Bonus-Release and Alpha-Beta-Gold

Note that workers may take any available issue, so it's not necessary that the
issues be strictly serial. Generally, any available MVP issues should be
preferred over Bonus issues. It is perfectly acceptable that MVP issues depend
on Bonus issues, as dependency trumps feature priority. It's also fine for
issue planners to classify an issue in the MVP because it's required for
another issue which is in the MVP set.

==== Feature Groups ====

While the basic idea of the project phase is to create iterative (though
sometimes internal) releases, only the public releases actually need to be
iterative. Internal releases / milestones may be developed in parallel and,
for instance, it's perfectly fine



The current availble issues may also be ordered within each project phase
according to priority. 'Priority' is, however, considered a secondary
attribute.

Issues are also organized into 'project components' (=~ sub-projects). It is
sometimes useful to filter issues based on the project component
