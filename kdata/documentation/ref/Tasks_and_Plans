<div id="Overview" class="blurbSummary grid_12">
  <div class="p">
    A <code>task</code> is a unit of work which produces definite and potentially
    actionable results. A 'task plan', or just 'plan', is the logic which (in
    part) drives task creation. The plan is the driver of any project and
    represents the concrete knowledge of an ecosystem.
  </div>
</div><!-- .blurbSummary#Overview -->
<div id="Life-of-a-Task" class="blurbSummary grid_12">
  <div class="blurbTitle">Life of a Task</div>
  <div class="p">
    Looking at all the <code>instructions</code> in a full
    blown <code>plan</code> can be daunting and we usually deal with plaans by
    zooming in on a particular area, or even just a single interaction. You
    can think of the <code>plan</code> as one of
    those <a href="http://en.wikipedia.org/wiki/Choose_Your_Own_Adventure">Choose
    Your Own Adventure</a> books.<span class="note">Zane wonders if these
    books taught him coding. Probably not, but good myth.</span> It's
    interesting, because it represents not a single story, but many potential
    stories. In the same way, a <code>plan</code> lays out the kind of things
    a project may do.


Plan cluster: divide plans by project. An ecosystem is created by selecting a
    number of base level projects, sufficient to keep things self
    contained. Base projects are those which rely only base resources. (They
    may define additional resources.)

Ecosystem map shows 1-degree from each resource...

    Each instruction refers to a 'this' which is some 'thing', either
    a <code>resource</code> or a <code>resource</code>
    item. E.g., <code>/tasks<code> or a <code>task</code>. In any
    case, <code>instructions</code> always deal with a thing. The instruction
    is matched by the thing and method: GET, PUT, POST, and DELETE, optional
    system telemetry, and&mdash;for GET and POST&mdash;the before and after
    data snapshots.

    Critically instructions are always executed after the operation
    itself.<span class="note">We considered allowing pre-action instructions a
    well, inline with the <a href="http://spring.io">Spring</a> framework's
    'veto' methods. However, we decided that <code>plans</code> are going to
    be complicated enough if they just focus on defining operational process
    flow, for which post-action processing is sufficient. Pre-processing would
    allow us to take care of technical concerns
    with <code>instructions</code>, and thereby
    complicate <code>instructions</code> with technical ideas.</span> It is
    possible that a change in system state occurs, but the follow
    on <code>instructions</code> matching that change are not executed for
    whatever reason.

    Each <code>instruction</code> remembers whatever is important about the
    universe, and is able to react to changes at any point. When a resource
    changes,<span class="note">Recall that when any item within a resource
    changes, the resource is said to change as well.</span> we proactively
    ping all known instructions associated with the
    resource.<span class="note">These are the instructions tracked in the
    resource item itself, with <code>resources</code> tracked
    as <code>resource</code> items
    (including <code>/resources/resources</code>).</span> However, these
    alerts may fail or be incomplete, which is fine, because the instruction
    is able to tell at any point whether the resource has changed. The item
    will actually be locked against further changes until
    requried <code>instructions</code> are
    executed. Thus, the actual decision is always lazy, and asynchronous,
    though we can initiate the lazy check with a poke.

    Each <code>instruction</code> is like a page in that. Writing a good plan
    is very much like writing a good
    story.<span class="note">The <code>plan</code> is not the story itself,
    but rather describes many potential stories.</span>
  </div>
  <div class="p">
    The story is an ongoing series of tasks. 
  </div>
</div><!-- #Life-of-a-Task.blurbSummary -->
<div id="Example-Task-Sequence" class="blurbSummary grid_12">
  <div class="blurbTitle">Example Task Sequence</div>
  <div class="p">
    When you create an <code>ecosystem</code>, you will select a template
    ecosystem to copy. Ideally, the cloned ecosystem will set up some
    initial <code>tasks</code>
    and <code>instructions</code>. <span data-perspective="implementation">Recall
    the initial data is read from
    the <code>&lt;projects&gt;/kdata/initial/&lt;resources&gt;</code>
    directory.</span> This might set up the following story:
  </div>
  <div class="p">
    The system is set up and ready to go. That
    means <code>/users/initial-user</code> has been aliased to the user
    account created as part of the low level bootstrap. You now have a fully
    functional, though still very bare bones ecosystem. The first thing the
    ecosystem does is take you on a voyage of self discovery.
  </div>
  <div class="p">
    The default settings for the special <code>/users/initial-user</code> set
    <code>auto-stream-tasks=true</code>, which means that immediately after
    login, the user will be taken to their first
    task&mdash;to name the ecosystem<span data-perspective="!implementation">.</span><span data-perspective="implementation">&mdash;
    which might be defined as:
    <pre><code>
{ "self_URL" : : "/tasks/_setup-001-get-ecosystem-name",
  "satisfied_by" : "/simple-questions/_setup-001-ecosystem-name",
  "satisfied_when" : "is_answered",
  "assigned_to" : "/users/initial-user",
  "status" : "pending" }
    </code></pre>
    </span>
  </div>
  <div class="p">
    <span data-perspective="!implementation">The <code>task</code> is said to
    be satisfied by </span><span data-perspective="implementation">As you can
    see in the task definition, it is "<code>satisfied by</code>"</span> a
    specific <code>simple question</code>, which is a basic resource used to
    pose simple questions to human and automated
    operators<span data-perspective="!implementation">. In this case, it asks
    what to name the
    ecosystem.</span><span data-perspective="implementation">:
      <pre><code>
{ "self_URL" : "/simple-questions/_setup-001-get-ecosystem-name",
  "i18n_text" : "/messages/default_What_is_the_ecosystems_name?field=text-for-browser-l10n",
  "default" : "What is the ecosystem name?",
  "input_type" : "string",
  "answer" : NULL }
      </code></pre> which is presented to the user as a basic text input
      box.</span> When the question is answered, this updates the <code>simple
      question</code> resource,
      which <span data-perspective="!implementation">satisfies the
      task</span><span data-perspective="implementation">finds the
      original <code>task</code> based on the <code>satisfied_by</code>
      and <code>satisfied_when</code> fields</span>.
  </div>
  <div class="p">
    
  </div>
  
    
      <li>{ "self URL" : "/tasks/_setup-001-size-business"
            "satisfied by" : "/

Task <code>_setup-01-size</code> might 
      <li>If the user has cloned a business ecosystem template, then one of the
      pre-existing tasks is likely to be something satisfied
      by <code>/books/?field=total-count > 0</code>.</li>
      <li>The task is assigned to the initia

    Let's look at a few examples:

    Base Level Audits
    - trigger: 15th day of quarter
    - result: creates new task to manually audit that all books have a
    quarterly audit instruction scheduled

    Setup Accounting
    - trigger event: PUT /books
    - result: creates new task to create all new accounts

    - trigger event: PUT /books
    - result: creates new instruction to review /books/{new ID} in one
    quarter-annual.*(The DELETE action automatically clears any instructions
    bound to the item. Asynchronous instructions should delete themselves when
    'Item not found or deleted' is returned.)

     - trigger event: put /accounts
     - result: create task to verify required information positively attested
     by qualified operator.

     NOTE: I think we can get rid of the 'task chain' above. Maybe we talk
     about general 'user case' narratives as a good starting point for task
     implementation.



<div id="Instructions" class="blurbSummary grid_12">
  <div class="blurbTitle">Instructions</div>
  <div class="p">
    An <code>/instructions</code> item encodes a 
  </div>

Break out trigger talk. Trigger is matched by call URL and call results. An
  instruction may have multilpe triggers.

  <div class="p">
    <ul>
      <li>The instruction triggers:
	<ul>
	  <li>Trigger resource URL.</li>
	  <li>Trigger HTTP method.</li>
	  <li>(FUTURE) For collection POST and DELETE, collection, summary
	  field values are provided.</li>
	  <li>(FUTURE) For collection GET,POST, or DELETE include
	  standard search mask and set comparison function.</li>
	  <li>(FUTURE) For collection POST triggering field name set
	  and set comparison function.</li>
	  <li>For an item resource POST triggering field names and set comparison
	  function.</li>
	  <li>The resource URL to which we react.</li>
	  <li>The HTTP method.</li>
	</ul>
    </ul>
	The set comparison functions are: DISJOINT, UNION, EQUAL, SUBSET,
	SUPERSET.
  </div>
</div><!-- #Instructions.blurbSummary -->
<div id="Organizing-Subscriptions" class="blurbSummary grid_12"
     data-Perspective="implementation operations">
  <div class="blurbTitle">Organizing Subscriptions</div>
  <div class="p">
  </div>
</div><!-- .blurbSummary#Organizing-Subscriptions [data-Perspective="implementation operations"] -->
<div id="Minimal-Packaging" class="blurbSummary grid_12"
     data-Perspective="detailed implementation operations">
  <div class="blurbTitle">Minimal Packaging</div>
  <div class="p">
    A Conveyor environment is at any one point in time, conceptually the
    composition of project snapshots. We implement this idea very directly by
    implementing subscriptions as nothing more than a git
    URL.<span data-perspective="detailed"> Though it hasn't been implement in
    with the standard implementation, the design is meant to add support for
    any versioning system supporting URLs and specific snapshots and/or
    branches could be quickly implemented.
  </div>
  <div class="p">
    However, we intentionally want to push this idea of using plain old git,
    combined with specific branch management and deployment strategies. With a
    few small tweaks, we can cover all the features we need with nothing but
    standard git. It's not something that will surface for most users, but
    the technical or curious, the good news and a nice feature about Conveyor
    is that you can really manage your deployments quite effectively, with the
    ability to roll back, isolate changes for testing, and ensure auditable
    processes all by just using git&mdash;which isn't the simplest application
    in the world, but is just about no more complex than really necessary.
  </div>
</div><!-- .blurbSummary#Organizing-Subscriptions [data-Perspective="implementation operations"] -->
