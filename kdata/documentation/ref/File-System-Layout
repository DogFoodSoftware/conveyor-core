<div id="Overview" class="blurbSummary grid_12">
  <div class="p">
    A Conveyor runtime is laid out on disk under the 'Conveyor
    playground'. Layout within the playground is discussed in terms of the
    project layout, and intra-project contents.
  </div>
</div>
<div id="Project-Layout" class="blurbSummary grid_12">
  <div class="blurbTitle">Project Layout</div>
  <div class="p">
    All project files are organized within a single project home
    directory. The project exist entirely within the Conveyor playground. The
    playground location is specified when the conveyor core is installed. The
    default value is <code>$HOME/playground</code>.
  </div>
  <div class="p">
    Within this playground, each project declares the location of it's home
    directory. All operatings dealing with the project must make no assumption
    regarding the location of the project home directory within the
    playground. However, we do require public projects to conform to certain
    conventions to be considered Conveyor compliant.
  </div>
  <div id="Organization-Namespaces" class="subHeader"><span>Organization Namespaces</span></code>
  <div class="p">
    Within the playground, each project should be rooted in a directory named
    after an root internet domain owned by the organization / individual
    owning the project. E.g., the core Conveyor development is done by Dog
    Food Software, LLC and organized under the
    directory <code>dogfoodsoftware.com<code>. Private projects need need not
    follow this convention.
  </div>
  <div class="p">
    The namespace owners are free to organize projects within this namespace
    any way they see fit. Projects may be organized into groups, sub-groups,
    etc. Some or all projects may be placed directly under the organization's
    root directory.
  </div>
</div><!-- #Project-Layout -->
<div id="Intra-Project-Files" class="blurbSummary grid_12">
  <div class="blurbTitle">Intra-Project Files</div>
  <div class="p">
    Within each project, Conveyor mandates compliance to the following tree:
    <ul>
      <li><code>bin/</code>: executable (binaries and scripts) specific to the
	project. These files are updated exclusively by task changes.</li>
      <li><code>conf/</code>: configuration files for Conveyor and other
	Conveyor projects. These files are update exclusively by tasks
	changes.<span data-perspective="detailed"> Some projects, however, may
	maintain runtime configuration files under the <code>/data</code>
	directory.</li>
      <li><code>data/</code>: contains runtime dynamic data, such as database
	files. This directory is always ignored by the git repo. The contents
	are generally updated by runtime logic. Updates may come in through
	task changesas well, these mostly representing structural/model
	changes.</li>
      <li><code>static-data/</code>: contains (relatively) static data, like
	documentation pages. These files are updated exclusively through task
	changes.</li>
      <li><code>static-media/</code>: contains (relatively) static media
	resources which may directly accessed and served by the HTTP
	server. E.g., images, video, etc. Smaller files may be included
	directly, and larger files are generally included by reference to an
	external directory. E.g., as a symlink. These files are updated
	exclusively by task changes.</li>
      <li><code>runnable/</code>: contains the runtime-ready files. In many
	cases&mdash;as with PHP projects&mdash;<code>runnable</code> is a
	sym-link to the <code>src/</code> directory. In this
	case, <code>runnable</code> is included in the git repo. In casess
	where the project src does need to be compiled, <code>runnable</code>
	is generated at install time and ignored by git. These files are
	updated exclusively through task changes.</li>
      <li><code>src/</code>: this is where all source / code files live. These
	files are updated exclusively by task changes.</li>
    </ul>
  </div>
  <div class="subHeader"><span>Dynamic vs. Static Bits</span></div>
  <div class="p">
    Generally, only the <code>/data</code> directory is updated directly by
    the runtime. All other files / data is updated by 'task changes'. This
    means the bits are tracked by git and updated on task branches which are
    then merged into the published branches (both development and
    production). When changes are pulled in for the branches, this triggers
    updates in the data as the task changes are incorporated.
  </div>
  <div data-perspective="future" class="p">
    To complicate things a bit, future Conveyor runtime will support
    seamlessly creating and merging task changes through the runtime. This
    means that operations like content management,
    effecting <code>static-resources</code> and <code>static-data/</code> for
    instance, may be made through the Conveyor front end. In this case, the
    change is facilitated through runtime logic, and also still exclusively
    accomplished within the context of a task change.
  </div>
  <div class="subHeader"><span>Directory Sub-Divisions</span></div>
  <div class="p">
    <ul>
      <li><code>bin/</code>: should contain all scripts directly. Library
	components will be stored under <code>src/lib</code> and accessed
	through <code>runnable/lib</code>.</li>
      <li><code>conf/</code>: should contain all configuration files directly
	unless things get crowded (+/-20 files). Projects may also subdivided
	to respect project requirements.</li>
      <li><code>data/</code>: contents are entirely defined by the
	project. Further details and recommendations discussed under
	the <a href="#Portability-and-Coherence-Guidelines">portability and
	  adherence guidelines</a>.</li>
      <li><code>static-data/</code>: contents are defined by the containing
	project and other projects. Specifically,
	the <a href="http://dogfoodsoftware.com/projects/kwiki">kwiki</a>
	projects expects <code>static-data/kwik</code></li>
      <li><code>static-resources/</code>: contains (relatively) static
	resources which may directly accessed and served by the HTTP
	server. E.g., images, video, etc. Smaller files may be included
	directly, and larger files are generally included by reference to an
	external directory. E.g., as a symlink. These files are updated
	exclusively by task changes.</li>
      <li><code>runnable/</code>: contains the runtime-ready files. In many
	cases&mdash;as with PHP projects&mdash;<code>runnable</code> is a
	sym-link to the <code>src/</code> directory. In this
	case, <code>runnable</code> is included in the git repo. In casess
	where the project src does need to be compiled, <code>runnable</code>
	is generated at install time and ignored by git. These files are
	updated exclusively through task changes.</li>
      <li><code>src/</code>: this is where all source / code files live. These
	files are updated exclusively by task changes.</li>
    </ul>
  </div>
</div><!-- #Intra-Project-Files -->
<div id="Portability-and-Coherence-Guidelines" class="blurbSummary grid_12">
  <div class="blurbTitle"><span>Portability and Coherence Guidelines</div>
  <div class="p">
    These guidelines are intended to help developers create and manage
    projects so they may be cleanly updated, backed up, restored, installed,
    and deleted largely independent of one another. The section consists
    mostly of recommendations rather than requirements. 
 </div>
  <div class="subHeader"><span>Segregate Data by Project</span></div>
  <div class="p">
    Both dynamic and static data should generally be segragated by the
    'consumer' project. Particularly, the <code>data/</code>
    and <code>static-data</code> directories ideally contain sub-directories
    named after projects. The files within those directories are ultimately
    consumed / managed by code living within the named project.
  </div>
  <div class="p">
    This means that you will often find a <code>data/foo</code> directory in
    the 'foo' project runtime layout. These are referred to as 'project data
    directories'. Other common breakouts in the current release
    include <code>postgres/</code> and <code>kwiki/</code>.
  </div>
  <div class="p">
    It is common for these files to 'live' under the project hosting the
    service which creates / manages the files and referenced from related
    locations. For instance, you might
    have <code>~/postgres/data/postgres/db</code> where the DB bits are stored
    (hard links) and <code>~/foo/data/foo/postgres/db</code> as symlink to the
    postgres directory.
  </div>
  <div class="p">
    In other instances, as with kwiki&mdash;where data can be easily /
    naturally distributed&mdash;you will find data consumed by project A
    living under project B's <code>data/</code> directory. For instance, kwiki
    documentation would live
    under <code>~/foo/static-data/kwiki/documentation</code>. In this case,
    'foo' is the data creator / manager and 'kwiki' is conceptually a strict
    consumer. This distinction is often driven by operational realities. In
    practice, <code>data/<code> files tend to be concentrated and refenced by
    distributed projects while <code>static-data/<code> tends to live under
    distributed projects. Distributed data is not generally referenced by the
    consumer in the file system.
  </div>
  <div class="subHeader"><span>Logs and Runtime Configuration</span></div>
  <div class="p">
    Within the project data directories under <code>data/</code>, it's
    considered polite to use <code>logs/<code> and <code>ext-conf/<code> for
    log files and generated / runtime configuration files respectively. Each
    of these directories may be further subdivided as convenience /
    necessary. Developers should not rely on runtime configuration or logs to
    be located here as it may not always be possible.
  </div>
  <div class="p">
    Log files generally live in the project providing the service which
    atually generates the log files. So, postgres logs would be found
    under <code>~/postgres/data/postgres/logs</code>. When appropriate,
    projects should create symbolic links to these canonical files;
    i.e. <code>~/foo/data/foo/logs/postgres-logs<code>.
  </div>
</div><!-- #Runtime-Layout.blurbSummary -->
<div id="Repository-Layout" class="blurbSummary grid_12">
  <div class="blurbTitle">Repository Layout</div>
  <div class="p">
    The repository layout deals exclusively with the naming and organization of
    projects within a repository. The layout of the repos contents are
    described in the <a href="#Runtime-Layout">runtime layout</a>.
  </div>
  <div class="p">
    With a vanilla git sever&mdash;where repositorys are just directories on
    some host&mdash;it is permissible to layout the projects in the same
    manner as a <a href="#Runtime-Projects">runtime project
    layout</a>. However, we want to Conveyor projects to be compatible with
    GitHub, which is rather more limited in it's layout options, and hence
    define an alternative repository layout.
  </div>
  <div class="p">
    Conveyor itself does not enforce any particular GitHub naming
    scheme. The <code>&lt;project&gt;/conf/conveyor-conf.sh</code> file
    specifies the runtime loctaion of the project (which is more tightly
    regulated), and there is no hard connection between the two
    names. However, in order to make it easier for humans to find projects on
    GitHub, we recommend the following conventions.
  </div>
  <div class="p">
    Specifically, whereas a basic filesystem allows arbitrary nesting, GitHub
    allows only a single level of file grouping under an 'Organization'. The
    first level domain folder in the runtime should be mapped to a GitHub
    Organization. The GitHub Organizations should be related to the domain
    name, but is not usually itself a domain name. For instance, the Conveyor
    core packages are installed under <code>dogfoodsoftware.com</code> in a
    runtime environment, while the GitHub Organization is 'DogFoodSoftware'.
  </div>
  <div class="p">
    The (potentially) nested project structure from the runtime layout is
    necessarily flattened. In order to facilitate organization, containing
    folders are generally pre-pennded to the project
    name. E.g. the runtime <code>~/dogfoodsoftware.com/conveyor/core</code>
    becomes <code>/DogFoodSoftware/conveyor-core.git</code> on GitHub.
  </div>
  <div class="p">
    Developers managing many projects, or wishing to separate key projects
    into their own groups, may break up the GitHub projects further by
    introducing additional 'Organizations', which in this case are used more
    as groups. These groups should, but are not required, to reflect the
    organization name. E.g., in the future, we expect to migrate the Dog Food
    Software jQuery projects to 'DFS-jQuery'
  </div>
</div><!-- #Repository-Layot.blurbSummary -->
