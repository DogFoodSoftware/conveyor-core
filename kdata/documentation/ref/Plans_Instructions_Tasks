<div id="Overview" class="blurbSummary grid_12">
  <div class="p">
    Here's the basic idea: <code>plans</code> encode institutional
    knowledge. <code>Instructions</code> are the individual steps
    in <code>plans</code>. <code>Tasks</code> are the mechanism by which
    a <code>instructions</code> are carried out. Together, the
    Plan/Instruction/Task resources, referenced collectively as PIT, are a
    central idea in the Conveyor system.
  </div>
  <div class="p">
    PIT is capable of capturing a broad range of institutional
    knowlede. Current <code>plans</code> range from corporate accounting to
    marketing to product development and personal excercise programs.
  </div>
</div><!-- .blurbSummary#Overview -->
<div id="Example-Task-Sequence" class="blurbSummary grid_12">
  <div class="blurbTitle">Example PIT Cycle</div>
  <div class="p">
    If you ever create
    an <code>ecosystem</code><span data-perspective="detailed" data-todo="Link
    to some info about setting up your own ecosystem."> (something we
    encourage you to do)</span>, it will come pre-loaded with
    a <code>plan</code> on how to complete the ecosystem
    setup.<span data-perspective="implementation"><span class="note"
    data-todo="Link this">Recall, the initial data is read from
    the <code>&lt;projects&gt;/kdata/initial/&lt;resources&gt;</code>
    directory.</span></span> The <code>plan</code> will most likely include
    an <code>instruction</code> to make sure the ecosystem gets
    named<span data-perspective="!implementation">.</span><span data-perspective="implementation">&mdash;
    which might be defined as:
    <pre><code>
{ "id" : "/tasks/liquid-labs.com/ecosystem-setup/ensure-name",
  "state" : "potential",
  "status" : "open",
  "aliases" : [{ "name" : "name",
                 "value" : "(/ecosystem/this?fields=name).name" }],
  "trigger" : "name == null || name.isEmpty()",
  "assign-to" : "ecosystem admin",
  "value" : "HIGH",
  "cardnality" : "one-at-a-time"
  "description" : "Please add a name to the &lt;a href=\"/ecosystem/this\"&gt;ecosystem&lt;/a&gt;." 
}
    </code></pre></span>
  </div>
  <div class="p">
    That <code>instruction</code> will be triggered when the ecosystem has no
    name.<span data-perspective="detailed implementation operations"> Specifically, when
    the <code>name</code> field of the special <code>/ecosystem</code>
    resource is null.</span> This will generate
    a <code>task</code><span data-perspecive="!implementation">.</span><span data-perspective="implementation">
    <pre><code>
{ "self_URL" : "/tasks/liquid-labs.com/setup/get-ecosystem-name",
  "satisfied_by" : "/simple-question/liquid-labs.com/setup/get-ecosystem-name",
  "check_URL" : "/ecosystem/?fields=name",
  "check_condition" : "name != null && !name.isEmpty()",
  "assigned_to" : "/users/initial",
  "status" : "pending",
  "value" : "HIGH",
  "manual_order" : 1,
  "pass_status" : "closed" }
    </code></pre></span>
    The <code>task</code> is satisfied when the ecosystem is named. This
    closes the loop.
  </div>
</div><!-- #Example-PIT-Cycle.blurbSummary -->
<div id="Plans" class="blurbSummary grid_12">
  <div class="blurbTitle">Plans</div>
  <div class="p">
    <code>Plans</code> organize instructions according to a purpose. The scope
    of a <code>plan</code> is defined by the <code>plan</code> author(s) and
    may be very narrow or quite broad. <code>Plans</code> cover technical
    issues, like how data backup procedures, as well as 'human' level
    processes, such as product ideation. <code>Plans</code> are created and
    maintained as <code>projects</code> artifacts.
  </div>
</div><!-- #Plans.blurbSummary -->
<div id="Instructions" class="blurbSummary grid_12">
  <div class="blurbTitle">Instructions</div>
  <div class="subHeader"><span>Each <code>Instructions</code> Creates a
  single <code>Task</code></span></div>
  <div class="p">
    When triggered, an <code>instruction</code> generates a single
    <code>task</code>.<span data-perspective="detailed future implementation">
    <span class="note">We have considered and may end upsupporting
    multiple <code>tasks</code> per <code>instruction</code>, if we can find a
    compelling use case. The current thinking is that this will not be
    necessary, and instead a <code>task</code> may spur the creation of
    mulitple sub-<code>tasks</code>.</span></span> This means two
    things. First, each <code>instruction</code> defines a single
    resolution <code>task</code> and so long as that <code>task</code> is
    non-closed, the <code>instruction</code> will create no further tasks.
  </div>
  <div class="subHeader"><span><code>Instructions</code> are Symettric with
  their <code>Task</code></span></div>
  <div class="p">
    The <code>task</code> generated by the <code>instruction</code> is
    symettric in that the <code>task</code> is satisfied when the condition
    that triggered the <code>instruction</code> is no longer true. In our
    example, above, the <code>instruction</code> is triggered by lack of an
    ecosystem and the <code>task</code> is satisfied when a name is
    provided.<span data-perspective="future"><span class="note">In the current
    implementation, this relationship may be expressed, but is not technically
    necessary. In future versions, we may modify the design such
    that <code>task</code> satisfaction is essentially tied to
    the <code>instruction</code> trigger.</span></span>
  </div>
  <div data-perspective="detailed implementation operations">
  <div class="subHeader"><span><code>Instructions</code> are Only for <code>Tasks</code></span></div>
  <div class="p">
    The <code>instruction</code>/<code>task</code> system is certainly capable
    of asynchronous message passing to automated agents and such, and forms
    the basis of many interesting systems. This use falls within the design
    scope.
  </div>
  <div class="p">
    One simple idea is to use <code>instructions</code> to implement automatic
    action, such as sending a text message (via REST call) when we see the
    error rates above a certain threshold. In the current system, we are
    limited to tasking an actor to look into it.<span class="note">There's
    nothing to stop <code>tasks</code> from supporting text messaging, which
    would be our suggested approach to this feature.</span>  But this isn't
    straightforward because <code>tasks</code> are part of how we make sure
    someone takes responsibilities for issues. The user has to acknowledge
    a <code>task</code>, but not a text message, so now we have to think a lot
    more abet the implications of instructions because we've removed the
    guaranteed involvement of the intelligent actor in resolving the situation
    that triggered the <code>instruction</code>.
  </div>
  <div class="p">
    With many "other ways" to use instructions, you run into problems
    regarding guaranteed delivery, the possibility of state change between
    trigger and resolution, etc. It's great to automate stuff, we just don't
    want to do it through the <code>instruction</code>/<code>task</code>
    system.
  </div>
  </div><!-- [data-perspectives="detailed implementation operations"] -->
  <div id="Instructions-are-Reactions-to-Valid-Changes"
  class="subHeader"><span><code>Instructions</code> are Reactions to Valid
  Changes</span></div>
  <div class="p">
    Instructions are executed after a valid change in state. A call that
    results in a FORBIDDEN or fails due to server error will never directly
    trigger an <code>instruction</code> because these calls cannot result in
    valid state changes.<span class="note">The term 'valid state change' is
    used here to mean a change in data&mdash;or state&mdash;which is 'valid as
    designed'. Neither FORBIDDEN nor failed requests should ever result in
    state change. Due to bugs or hardware failures, they may of course result
    in state change, but that state change is considered invalid with respect
    to the design. Rejected or failed update a logging or audit resource,
    which itself may trigger instructions; e.g., task an admin to look into
    the logs whenever there's an error reported. This is why we say 'never
    result in <em>direct</em> change', as we consider the case mentioned here
    to be very much indirect.</span>
  </div>
  <div class="subHeader"><span><code>Instructions</code> Verify Knowledge</div>
  <div class="p">
    While <a href="#Instructions-are-Reactions-to-Valid-Changes"><code>instructions</code>
    are recations to valid changes</a>, <code>instructions</code> are
    fundamentally encoded knowledge. Our example instruction from above
    encodes the idea that the ecosystem should have a name. The instruction
    can be run at any time, and an ecosystem is constantly running through
    it's set of instructions to see what needs to be done.
  </div>
  <div class="p" data-perspective="detailed implementation operations">
    You may think this sounds innefficient, and from the standpoint of
    'minimizing REST calls', it certainly is. You might check an instruction
    hundreds of time before detecting a change. You could therefore think it
    reasonable to trigger instructions, like event handlers, and avoid all the
    unecessary checks. The big problem here is that because we don't assume
    all <code>instructions</code> effecting a system to be on the same
    ecosystem, let alone the same host, it would be very costly to guarantee
    all <code>instructions</code> get the message regarding the change in a
    timely fashion. This would make instructions more complex, because they
    now need to deal with late alerts. As is, the idea would be that if the
    ecosystem name were deleted, and then immediately re-entered, the 'ensure
    ecosystem has a name' <code>instruction</code> mightnever be triggered,
    but so what? It's fine for instructions, so long as you remember it's not
    an event processing framework. It's more like constant unit tests fro the
    business.
  </div>
  <div class="subHeader"><span>Lazy vs. Proactive <code>Instructions</code></span></div>
  <div class="p">
  </div>
</div><!-- #Instructions.blurbSummary -->
<div id="Planning" class="blurbSummary grid_12">
  <div class="blurbTitle">Planning</div>
  <div class="p">
    <code>Instructions</code> are the end product of planning out and
    capturing institution process and knowledge. Looking at all
    the <code>instructions</code> and considering all the
    potential <code>tasks</code> in a full blown <code>plan</code> can be
    daunting.
  </div>
  <div class="subHeader"><span>User Stories</span></div>
  <div class="p">
    Each <code>instruction</code> <em>should</em> document it's semantic
    purpose and ground itself fully it's it's own raison d'être, which should
    most often ground itself in a user story. This should not be taken to mean
    that a formal user story must procede creation of an instruction, but
    rather that mature <code>instructions</code> are expected to be able to
    explain themselves.
  </div>
  <div class="p">
    For larger projects, a more formal connection between instructions and
    user stories may be useful. Though the relation may not be 1-1, user
    stories are a useful lens for understanding, implementing, and
    verifying <code>instructions</code>.
  </div>






  </div>
  <div class="p">
    The story is an ongoing series of tasks. 
  </div>
</div><!-- #Life-of-a-Task.blurbSummary -->

  <div class="p">
    As configured, the user will go
  </div>
  
    
      <li>{ "self URL" : "/tasks/_setup-001-size-business"
            "satisfied by" : "/

Task <code>_setup-01-size</code> might 
      <li>If the user has cloned a business ecosystem template, then one of the
      pre-existing tasks is likely to be something satisfied
      by <code>/books/?field=total-count > 0</code>.</li>
      <li>The task is assigned to the initia

    Let's look at a few examples:

    Base Level Audits
    - trigger: 15th day of quarter
    - result: creates new task to manually audit that all books have a
    quarterly audit instruction scheduled

    Setup Accounting
    - trigger event: PUT /books
    - result: creates new task to create all new accounts

    - trigger event: PUT /books
    - result: creates new instruction to review /books/{new ID} in one
    quarter-annual.*(The DELETE action automatically clears any instructions
    bound to the item. Asynchronous instructions should delete themselves when
    'Item not found or deleted' is returned.)

     - trigger event: put /accounts
     - result: create task to verify required information positively attested
     by qualified operator.

     NOTE: I think we can get rid of the 'task chain' above. Maybe we talk
     about general 'user case' narratives as a good starting point for task
     implementation.



<div id="Instructions" class="blurbSummary grid_12">
  <div class="blurbTitle">Instructions</div>
  <div class="p">
    An <code>/instructions</code> item encodes a 
  </div>

Break out trigger talk. Trigger is matched by call URL and call results. An
  instruction may have multilpe triggers.

  <div class="p">
    <ul>
      <li>The instruction triggers:
	<ul>
	  <li>Trigger resource URL.</li>
	  <li>Trigger HTTP method.</li>
	  <li>(FUTURE) For collection POST and DELETE, collection, summary
	  field values are provided.</li>
	  <li>(FUTURE) For collection GET,POST, or DELETE include
	  standard search mask and set comparison function.</li>
	  <li>(FUTURE) For collection POST triggering field name set
	  and set comparison function.</li>
	  <li>For an item resource POST triggering field names and set comparison
	  function.</li>
	  <li>The resource URL to which we react.</li>
	  <li>The HTTP method.</li>
	</ul>
    </ul>
	The set comparison functions are: DISJOINT, UNION, EQUAL, SUBSET,
	SUPERSET.
  </div>
</div><!-- #Instructions.blurbSummary -->
<div id="Organizing-Subscriptions" class="blurbSummary grid_12"
     data-Perspective="implementation operations">
  <div class="blurbTitle">Organizing Subscriptions</div>
  <div class="p">
  </div>
</div><!-- .blurbSummary#Organizing-Subscriptions [data-Perspective="implementation operations"] -->
<div id="Minimal-Packaging" class="blurbSummary grid_12"
     data-Perspective="detailed implementation operations">
  <div class="blurbTitle">Minimal Packaging</div>
  <div class="p">
    A Conveyor environment is at any one point in time, conceptually the
    composition of project snapshots. We implement this idea very directly by
    implementing subscriptions as nothing more than a git
    URL.<span data-perspective="detailed"> Though it hasn't been implement in
    with the standard implementation, the design is meant to add support for
    any versioning system supporting URLs and specific snapshots and/or
    branches could be quickly implemented.
  </div>
  <div class="p">
    However, we intentionally want to push this idea of using plain old git,
    combined with specific branch management and deployment strategies. With a
    few small tweaks, we can cover all the features we need with nothing but
    standard git. It's not something that will surface for most users, but
    the technical or curious, the good news and a nice feature about Conveyor
    is that you can really manage your deployments quite effectively, with the
    ability to roll back, isolate changes for testing, and ensure auditable
    processes all by just using git&mdash;which isn't the simplest application
    in the world, but is just about no more complex than really necessary.
  </div>
</div><!-- .blurbSummary#Organizing-Subscriptions [data-Perspective="implementation operations"] -->
