<div id="Overview" class="blurbSummary grid_12">
  <div class="p">
    The Conveyor command line interface (CLI) is accessed through
    the <code>con</code> command, which is installed as part of the
    core Conveyor package. The CLI syntax follows and maps directly to
    the <a href="Conveyor-REST-API-Standards">Conveyor REST API</a>.
  </div>
</div>
<div id="Basic-Syntax" class="blurbSummary grid_12">
  <div class="blurbTitle">Basic Syntax</div>
  <div class="p">
    The basic syntax is:
<pre><code>
con [action] &lt;resource&gt; [[param1=value1]...]
</pre></code> Where 'action' is one
    of <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>PATCH</code>,
    or <code>DELETE</code>. If the first argument is anything but
    these five options (ignoring case), the the default
    action <code>GET</code> is assumed and the first argument is
    interpretted as a resource identifier. Following the resource
    identifier are zero or more parameters. Parameters may be required
    or optional based on the resource and action. The CLI result code
    follow HTTP standards for the most part and unrecognized
    parameters and invalid parameter values will result in a '400'
    See <a href="#CLI-Return-Codes">CLI Return Codes</a> for more
    details.  response.
  </div>
</div><!-- #Basic-Syntax -->
<div id="CLI-Return-Codes" class="blurbSummary grid_12">
  <div class="blurbTitle">CLI Return Codes</div>
  <div class="p">
    As mentioned, the <code>con</code> command will exit / return with
    the equivalent HTTP response code, excepting that '201'
    ('created') for <code>PUT</code> and '200' ('OK') for all other
    successful actions will result in a bash return code of '0'. User
    agents should expect '0' (== 200/201) or any of the 4xx and 5xx
    return codes. The CLI will never respond with 3xx statti.
  </div>
</div><!-- #CLI-Return-Codes -->
<div id="CLI-Output" class="blurbSummary grid_12">
  <div class="blurbTitle">CLI Output</div>
  <div class="p">
    The <code>con</code> command will output informational and error
    reports to the user, as well as any data received from the
    call. The particular behavior may be influenced
    by <code>-q|--quite</code>, <code>-qq|--very-quite</code>,
    and <code>--verbose</code> flags.
  </div>
  <div class="subHeader"><span>Informational Output</span></div>
  <div class="p">
    Informational output are informational messages intended primarily
    for a human operator. There are four classes of informational
    messages: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>,
    and <code>ERROR</code>.<span data-perspective="detailed">
    Following bash conventions, the first two are sent
    to <code>stdin</code> and the latter two
    to <code>stderr</code>.</span> The default behavior is to
    show <code>INFO</code>, <code>WARNING<code>,
    and <code>ERROR</code> messages. <code>DEBUG</code> messages will
    be output if the <code>--verbose</code> flag is included,
    while <code>-q|--quite</code> suppresses <code>INFO</code>
    and <code>-qq|--very-quite</code> suppresses all output (in which
    case the user is expected to refer to the return code to determine
    the basic status of the result).
  </div>


  <div data-perspective="detail" class="p">
    The distribution is primarily specified by
    the <code>conveyor-packages.nix</code> file and the contents of
    the <code>pkgs</code> directory. We point nix at
    the <code>conveyor-packages.nix</code> file. The installation for
    each project is defined in the <code>pkgs</code> directory. Note
    that the packages themselves do not typically define their own
    installation. It's the job of the distribution to set up the
    runtime, and so it is responsible for actually incorporating the
    projects. This also allows us to draw a clean line between project
    development and distribution definition.
  </div>
  <div data-perspective="detail" class="p">
    It is sometimes useful to divide the Nix packages into three
    classes. The first division is between Conveyor and sub-Conveyor
    packages (mostly libraries) required to build Conveyor stack
    components. These are typically defined by Nix and imported into
    the <code>conveyor-packages.nix</code> file.
  </div>
  <div data-perspective="detail" class="p">
    The second division is between 'wrapped' and 'full' Conveyor
    packages. Stack components and 3rd party libraries are often
    wrapped. This means they will have an installer in the
    distribution <code>pkgs</code> directory, but the installer is
    going to reference a non-Conveyor project. Any Conveyor specific
    configuration or modifications are stored in the distribution's
    package directory. Thus, to make a chance to the conveyor-apache
    (TODO: should be conveyor-apache-httpd) package (which wraps
    Apache HTTPD) you would work with the conveyor-distro project and
    make modifications
    under <code>~/conveyor/distro/pkgs/servers/http/conveyor-apache</code>.
    The 'full' Conveyor packages just means that the source referenced
    in the package definitions is a Conveyor project.
  </div>
  <div data-perspective="coder sysops" class="p">
    The current distribution specification follows the standard
    distribution. It's entirely possible to create alternate
    distributions defining a different package set, targetting
    different hosts, and / or setting up a different runtime stack. In
    the current version we have not spent a much time separating the
    fundamental distribution specification applying to all
    distributions from the documentation and specification specifit to
    the standard distribution.
  </div>
</div><!-- .blurbSummary#Distribution -->

THE REMAINDER OF THIS DOCUMENT IS OUT OF DATE

<div id="Project-Layout" class="blurbSummary grid_12">
  <div class="blurbTitle">Project Layout</div>
  <div class="p">
    All project files are organized within a single project home
    directory. The project exist entirely within the Conveyor playground. The
    playground location is specified when the conveyor core is installed. The
    default value is <code>$HOME/playground</code>.
  </div>
  <div class="p">
    Within this playground, each project declares the location of it's home
    directory. All operatings dealing with the project must make no assumption
    regarding the location of the project home directory within the
    playground. However, we do require public projects to conform to certain
    conventions to be considered Conveyor compliant.
  </div>
  <div id="Organization-Namespaces" class="subHeader"><span>Organization Namespaces</span></code>
  <div class="p">
    Within the playground, each project should be rooted in a directory named
    after an root internet domain owned by the organization / individual
    owning the project. E.g., the core Conveyor development is done by Dog
    Food Software, LLC and organized under the
    directory <code>dogfoodsoftware.com<code>. Private projects need need not
    follow this convention.
  </div>
  <div class="p">
    The namespace owners are free to organize projects within this namespace
    any way they see fit. Projects may be organized into groups, sub-groups,
    etc. Some or all projects may be placed directly under the organization's
    root directory.
  </div>
</div><!-- #Project-Layout -->
<div id="Intra-Project-Files" class="blurbSummary grid_12">
  <div class="blurbTitle">Intra-Project Files</div>
  <div class="p">
    Within each project, Conveyor mandates compliance to the following tree:
    <ul>
      <li><code>bin/</code>: executable (binaries and scripts) specific to the
	project. These files are updated exclusively by task changes.</li>
      <li><code>conf/</code>: configuration files for Conveyor and other
	Conveyor projects. These files are update exclusively by tasks
	changes.<span data-perspective="detailed"> Some projects, however, may
	maintain runtime configuration files under the <code>/data</code>
	directory.</li>
      <li><code>data/</code>: contains runtime dynamic data, such as database
	files. This directory is always ignored by the git repo. The contents
	are generally updated by runtime logic. Updates may come in through
	task changesas well, these mostly representing structural/model
	changes.</li>
      <li><code>static-data/</code>: contains (relatively) static data, like
	documentation pages. These files are updated exclusively through task
	changes.</li>
      <li><code>static-media/</code>: contains (relatively) static media
	resources which may directly accessed and served by the HTTP
	server. E.g., images, video, etc. Smaller files may be included
	directly, and larger files are generally included by reference to an
	external directory. E.g., as a symlink. These files are updated
	exclusively by task changes.</li>
      <li><code>runnable/</code>: contains the runtime-ready files. In many
	cases&mdash;as with PHP projects&mdash;<code>runnable</code> is a
	sym-link to the <code>src/</code> directory. In this
	case, <code>runnable</code> is included in the git repo. In casess
	where the project src does need to be compiled, <code>runnable</code>
	is generated at install time and ignored by git. These files are
	updated exclusively through task changes.</li>
      <li><code>src/</code>: this is where all source / code files live. These
	files are updated exclusively by task changes.</li>
    </ul>
  </div>
  <div class="subHeader"><span>Dynamic vs. Static Bits</span></div>
  <div class="p">
    Generally, only the <code>/data</code> directory is updated directly by
    the runtime. All other files / data is updated by 'task changes'. This
    means the bits are tracked by git and updated on task branches which are
    then merged into the published branches (both development and
    production). When changes are pulled in for the branches, this triggers
    updates in the data as the task changes are incorporated.
  </div>
  <div data-perspective="future" class="p">
    To complicate things a bit, future Conveyor runtime will support
    seamlessly creating and merging task changes through the runtime. This
    means that operations like content management,
    effecting <code>static-resources</code> and <code>static-data/</code> for
    instance, may be made through the Conveyor front end. In this case, the
    change is facilitated through runtime logic, and also still exclusively
    accomplished within the context of a task change.
  </div>
  <div class="subHeader"><span>Directory Sub-Divisions</span></div>
  <div class="p">
    <ul>
      <li><code>bin/</code>: should contain all scripts directly. Library
	components will be stored under <code>src/lib</code> and accessed
	through <code>runnable/lib</code>.</li>
      <li><code>conf/</code>: should contain all configuration files directly
	unless things get crowded (+/-20 files). Projects may also subdivided
	to respect project requirements.</li>
      <li><code>data/</code>: contents are entirely defined by the
	project. Further details and recommendations discussed under
	the <a href="#Portability-and-Coherence-Guidelines">portability and
	  coherence guidelines</a>.</li>
      <li><code>static-data/</code>: as with <code>data/</code>, contents are
	defined on a per-project basis though we do
	provide <a href="#Portability-and-Coherence-Guidelines">portability
	and coherence guidelines</a>.</li>
      <li><code>static-media/</code>: typically broken out by 'kind'. At the
	moment, there is not a lot of regulation on how this is laid out and
	projects should consider all 'static-media' contents in all projects
	to exist within a single global namespace served.</li>
      <li><code>runnable/</code>: in many cases, this is just a symlink
      to <code>src/</code>. For projects with 'built' services, this will
      contain the built service binaries and should be segregated by
      such. There is currently no allowance for projects that contain both
      library / source code and built projects.</li>
      <li><code>src/</code>: this is typically divided into one or
      more <code>lib/<code>, <code>rest/</code>, <code>site/<code> and
      /or <code>ui/<code> directories.</li>
    </ul>
  </div>
</div><!-- #Intra-Project-Files -->
<div id="Portability-and-Coherence-Guidelines" class="blurbSummary grid_12">
  <div class="blurbTitle"><span>Portability and Coherence Guidelines</div>
  <div class="p">
    These guidelines are intended to help developers create and manage
    projects so they may be cleanly updated, backed up, restored, installed,
    and deleted largely independent of one another. The section consists
    mostly of recommendations rather than requirements. 
 </div>
  <div class="subHeader"><span>Segregate Data by Project</span></div>
  <div class="p">
    Both dynamic and static data should generally be segragated by the
    'consumer' project. Particularly, the <code>data/</code>
    and <code>static-data</code> directories ideally contain sub-directories
    named after projects. The files within those directories are ultimately
    consumed / managed by code living within the named project.
  </div>
  <div class="p">
    This means that you will often find a <code>data/foo</code> directory in
    the 'foo' project runtime layout. These are referred to as 'project data
    directories'. Other common breakouts in the current release
    include <code>postgres/</code> and <code>kwiki/</code>.
  </div>
  <div class="p">
    It is common for these files to 'live' under the project hosting the
    service which creates / manages the files and referenced from related
    locations. For instance, you might
    have <code>~/postgres/data/postgres/db</code> where the DB bits are stored
    (hard links) and <code>~/foo/data/foo/postgres/db</code> as symlink to the
    postgres directory.
  </div>
  <div class="p">
    In other instances, as with kwiki&mdash;where data can be easily /
    naturally distributed&mdash;you will find data consumed by project A
    living under project B's <code>data/</code> directory. For instance, kwiki
    documentation would live
    under <code>~/foo/static-data/kwiki/documentation</code>. In this case,
    'foo' is the data creator / manager and 'kwiki' is conceptually a strict
    consumer. This distinction is often driven by operational realities. In
    practice, <code>data/<code> files tend to be concentrated and refenced by
    distributed projects while <code>static-data/<code> tends to live under
    distributed projects. Distributed data is not generally referenced by the
    consumer in the file system.
  </div>
  <div class="subHeader"><span>Logs and Runtime Configuration</span></div>
  <div class="p">
    Within the project data directories under <code>data/</code>, it's
    considered polite to use <code>logs/<code> and <code>ext-conf/<code> for
    log files and generated / runtime configuration files respectively. Each
    of these directories may be further subdivided as convenience /
    necessary. Developers should not rely on runtime configuration or logs to
    be located here as it may not always be possible.
  </div>
  <div class="p">
    Log files generally live in the project providing the service which
    atually generates the log files. So, postgres logs would be found
    under <code>~/postgres/data/postgres/logs</code>. When appropriate,
    projects should create symbolic links to these canonical files;
    i.e. <code>~/foo/data/foo/logs/postgres-logs<code>.
  </div>
</div><!-- #Runtime-Layout.blurbSummary -->
<div id="Further-Reading" class="blurbSummary grid_12">
  <div class="blurbTitle">Further Reading</div>
  <ul class="p">
    <li><a href="/documentation/conveyor-core/ref/Projects#Project-Repositories">Discussion
    on naming and layout of project repositories.</a></li>
  </ul>
</div>
