#!/bin/bash
# /**
#  * <div id="Overview" class="blurbSummary grid_12">
# * Script allowing interaction with a Conveyor instance through a
# * <href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a> shell.
# * </div>
# * <div id="General-Form" class="blurbSummary grid_12">
# * <div class="blurbTitle">General Form</div>
# * <pre class="code">
# * convey [&lt;header option 1&gt;...] &lt;resource ID&gt; 
# *        &lt;action verb&gt; [&lt;option 1&gt;...]
# * </pre>
# * <div class="subHeader"><span>Header Options</span></div>
# * <div class="p">
# *   The header options mirror the options defined in the <a
# *   href="/documentation/conveyor/REST-Specification#Header-Options">Conveyor
# *   REST Specification</a>. There is currently a single option.
# * </div>
# * <ul class="p">
# *   <li><code>--accept|-a &lt;html|json|bash&gt;</code>: Option to define
# *   acceptable response media types. The option may be invoked mulitple
# *   times to specify multiple acceptable types. The order of specification
# *   is taken as the order of preference. The default value is 
# *   <code>bash</code>.
# * </ul>
# * <div class="subHeader"><span>Resounce ID</span></div>
# * <div class="p">
# *   The 'resource ID' specifies a particular resource item or
# *   to recieve the request. This is specified in the <a
# *   href="/documentation/conveyor/REST-Specification#Resource-ID">Conveyor
# *   REST Specification</a>.
# * </div>
# * <div class="subHeader"><span>Action Verb</span></div>
# * <div class="p">
# *   The 'action verb' completes the primary request by specifying what type
# *   of action to take on the identified resource. We follow the HTTP
# *   standard here and define four verbs. The HTTP verbs are, however, a bit
# *   cryptic, so we also provide an alias based on the more common database
# *   'CRUD' idiom.
# *   <table>
# *   <thead><tr>
# *     <td>CRUD</td><td>HTTP</td>
# *   </tr></thead>
# *   <tbody>
# *     <tr><td><code>CREATE</td><td><code>PUT</code></td></tr>
# *     <tr><td><code>RETRIEVE</td><td><code>GET</code></td></tr>
# *     <tr><td><code>UPDATE</td><td><code>POST</code></td></tr>
# *     <tr><td><code>DELETE</td><td><code>DELETE</code></td></tr>
# *   </tbody>
# *   </table>
# *   Consumers are free to use either. It is strongly encouraged that any
# *   particular script or artifact only use a single convention unless there
# *   is some clear semantic distinction to be gained by varying the idiom.
# * </div>
# * <div class="p">
# *   See the <a
# *   href="/documentation/conveyor/REST-Specification#Action-Verb">Conveyor
# *   REST Specification</a> for further details.
# * </div>
# * <div class="subHeader"><span>Options</span></div>
# * <div class="p">
# *   The final options are of two basic types. 'Request options' define
# *   characteristics of the request. The request options are each of a general
# *   type, but whose values are resource specific. These include:
# *   <ul>
# *    <li><code>fields</code>: the list of fields to include in the
# *    result.</li>
# *    <li><code>item-index</code>: requested item based index at which to
# *    start a paged view. Only valid for resource collections. Actual index
# *    returned may be adjusted to reflect maximum possible value.</li>
# *    <li><code>page-index</code>: requested paged based index at which to
# *    start a paged view. Only valid for resource collections. Actual index
# *    returned may be adjusted to reflect maximum possible value.</li>
# *    <li><code>page-size</code>: requested page size. Actual page sizde
# *    returned may be adjusted to respect constraints of the particular
# *    resource collection.</li>
# *   </ul>
# * </div>
# */

source $HOME/.conveyor/config
source $CONVEYOR_HOME/core/runnable/lib/convey-lib.sh
STATIC_PREFIX="/static-resources"
DYNAMIC_PREFIX="/runnable/rest"

# We use 'shflags' when we can, but I don't believe that supports the kind of
# array of options we want to do with '--accept'.
TMP=`getopt --name=$0 -a --longoptions=accept: -o a: -- $@`
eval set -- $TMP

OPTION_ACCEPTS=()
until [ $1 == -- ]; do
    case $1 in
	-a|--accept)
	    OPTION_ACCEPTS+=("$2")
	    shift;; # Remove option value.
    esac
    shift # Remove just-processed option.
done
shift # Remove the '--', now $1 positioned at first argument if any.

if [ ${#OPTION_ACCEPTS[@]} -eq 0 ]; the
    ACCEPTS=('bash')
else
    declare -a ACCEPTS=(${OPTION_ACCEPTS[@]})
fi

RESOURCE_ID="$1"; shift
ACTION_VERB="$1"; shift
# Options, if any, begin at $1

# First, a quick check that we have an absolute ID.
if [ ${RESOURCE_ID:0:1] == '/' ]; then
    echo "We do not currently support relative context. Please use absolute resource IDs." >&2
    exit 1
fi

# Okay, now we're set to satisfy the resource request. The order of preference
# for satisfying the request is, for each 'accept' type:
#
# 1) Static media satisfying the accept types.
# 2) A resource specific handler satisfying the accept type.
# 3) A class handler satisfying the accept type.
#
# Accordingly, the main function iterates over the specified accept types. For
# each type, it applies each of the the above searches until the search is
# satisfied, at which point control is handed off to the handler.
#
# We want to explore caching the results the determinations in a light weight
# DB of some sort, but for now, we try to optimize the <code>find<code>s as
# much as possible.

for ACCEPT in "${ACCEPTS[@]}"; do
    # 1) Static media search.
    FIND="find $CONVEYOR_PLAYGROUND -path '*/$


SLASHES="${RESOURCE_ID//[^/]}"
if [ ${#SLASHES} -eq 1 ]]; then
    # We are dealing with a resource collection.
    RESOURCE_HANDLER="$RESOURCE_ID/_collection-handler.sh"
else 
    # We are dealing with a particular item.
    RESOURCE_HANDLER="${RESOURCE_ID}.sh"
fi

HANDLER_BASENAME=`basename $RESOURCE_HANDLER"`
HANDLER_DIRNAME=`dirname $RESOURCE_HANDLER"`
HANDLER=`find -name "$HANDLER_BASENAME" -path "*$HANDLER_DIRNAME" | head -1`
if [ x"$HANDLER" != x"" ]; then
    "$HANDLER" "${ACCEPT[@]}" "$RESOURCE_ID" "$ACTION_VERB" $*
    exit $?
fi

# If we arrive here, it means we did not find any static handlers for the
# resource.
